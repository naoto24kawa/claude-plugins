# トレードオフ分析ガイド

このガイドは、複数のレビューエージェントから得られた提案を統合し、相反する推奨事項のバランスを取るための詳細な分析手法を提供します。

---

## 目次

1. [相反する提案の特定](#相反する提案の特定)
2. [トレードオフのパターン](#トレードオフのパターン)
3. [優先度判定基準](#優先度判定基準)
4. [バランス調整の方法](#バランス調整の方法)
5. [意思決定フレームワーク](#意思決定フレームワーク)

---

## 相反する提案の特定

### ステップ 1: 提案のカテゴリ分類

各エージェントの提案を以下のカテゴリに分類：

- **設計・アーキテクチャ**: クラス/関数の責任分離、モジュール構成
- **可読性・保守性**: 命名、コメント、構造の明確さ
- **性能・効率**: パフォーマンス最適化、リソース使用
- **型安全性**: TypeScript 型定義、型チェック
- **規約・一貫性**: コーディング規約、プロジェクト標準
- **整理整頓**: 不要ファイル削除、構成の整理

### ステップ 2: 矛盾の検出

同じコード箇所に対して異なる推奨がある場合を特定：

```
例:
- SRP: "この関数を3つに分割すべき"
- KISS: "この関数は十分シンプルなので分割不要"
```

### ステップ 3: 影響範囲の評価

各提案が他の部分に与える影響を分析：

- **直接影響**: 変更対象のコード自体
- **間接影響**: 依存するコード、呼び出し元
- **波及影響**: システム全体、チームの開発フロー

---

## トレードオフのパターン

### パターン 1: SRP vs KISS

**状況**: 責任分離とシンプルさのバランス

**判定基準**:

- 関数が 50 行以下 → KISS 優先（分割しない）
- 関数が 50-100 行 → 明確に異なる責任がある場合のみ分割
- 関数が 100 行以上 → SRP 優先（分割する）
- 将来的な変更頻度が高い → SRP 優先

**推奨アプローチ**:

```typescript
// 悪い例: 過剰な分割（KISS違反）
function processUser() {
  validateUserId();
  checkUserPermissions();
  loadUserData();
  formatUserResponse();
}

// 良い例: 適度なバランス
function processUser(userId: string) {
  const user = loadAndValidateUser(userId);
  return formatUserResponse(user);
}
```

---

### パターン 2: Code for Humans vs パフォーマンス

**状況**: 可読性と性能のバランス

**判定基準**:

- パフォーマンスボトルネックではない → 可読性優先
- ホットパス（頻繁に実行） → パフォーマンス優先、コメントで説明
- 開発初期段階 → 可読性優先（早すぎる最適化を避ける）
- 本番で性能問題が発生 → パフォーマンス優先

**推奨アプローチ**:

```typescript
// ボトルネックでない場合: 可読性優先
const activeUsers = users.filter((u) => u.isActive).map((u) => u.name);

// ボトルネックの場合: パフォーマンス優先 + コメント
// NOTE: この処理は1秒間に10000回実行されるため、
// 可読性よりもパフォーマンスを優先している
const activeUsers = [];
for (let i = 0; i < users.length; i++) {
  if (users[i].isActive) activeUsers.push(users[i].name);
}
```

---

### パターン 3: CoC vs 既存コードとの互換性

**状況**: 新しい規約と既存コードのバランス

**判定基準**:

- 新規プロジェクト → CoC 優先（規約を厳格に適用）
- 既存プロジェクト・小規模変更 → 互換性優先
- 既存プロジェクト・大規模リファクタリング → CoC 優先、段階的移行
- チームの合意が得られる → CoC 優先

**推奨アプローチ**:

1. **即時適用**: 新規ファイルのみ新規約を適用
2. **段階的移行**: 変更するファイルから順次新規約に移行
3. **一括移行**: 専用のブランチで全体を一度に移行

---

### パターン 4: TypeScript 型厳格性 vs 開発速度

**状況**: 型安全性と実装スピードのバランス

**判定基準**:

- 公開 API・ライブラリ → 厳格な型定義
- 内部実装 → 適度な型定義
- プロトタイピング段階 → 緩い型定義、後で厳格化
- 型エラーが実際のバグにつながる → 厳格化

**推奨アプローチ**:

```typescript
// 公開API: 厳格な型定義
export interface UserService {
  getUser(id: string): Promise<User>;
  updateUser(id: string, data: Partial<User>): Promise<User>;
}

// 内部実装: 適度な型定義
type InternalUserData = Pick<User, "id" | "name">;

// プロトタイプ: 緩い型定義（後で厳格化）
function experimentalFeature(data: any) {
  // TODO: 型を厳格化
}
```

---

## 優先度判定基準

### Critical（即時対応）の判定

以下のいずれかに該当する場合、Critical として分類：

1. **セキュリティ**

   - SQL インジェクション、XSS などの脆弱性
   - 認証・認可の不備
   - 機密情報の漏洩リスク

2. **データ整合性**

   - データ損失のリスク
   - トランザクション不整合
   - 競合状態によるバグ

3. **システム安定性**

   - クラッシュやハングの原因
   - メモリリーク
   - 無限ループ

4. **型安全性の重大な違反**
   - `any` の不適切な使用でランタイムエラーが発生
   - 型アサーションによる安全性の破壊

### High（優先的に対応）の判定

以下のいずれかに該当する場合、High として分類：

1. **保守性への大きな影響**

   - 200 行以上の巨大関数
   - 循環依存
   - 密結合による変更困難性

2. **将来的なバグのリスク**

   - エラーハンドリングの欠如
   - 境界値チェックの不足
   - 非同期処理の不適切な扱い

3. **パフォーマンスボトルネック**
   - N+1 クエリ
   - 不要な再レンダリング
   - メモリ使用量の問題

### Medium（計画的に対応）の判定

1. **コード品質の向上**

   - 可読性の改善
   - 重複コードの削減
   - 命名の改善

2. **規約違反**
   - コーディング規約の不統一
   - ドキュメント不足
   - テストカバレッジ不足

### Low（将来的な改善）の判定

1. **最適化・効率化**

   - より良いアルゴリズム
   - 新しいパターンの適用
   - 技術的負債の返済

2. **学習・改善機会**
   - より良い設計パターンの導入
   - 最新のベストプラクティス適用

---

## バランス調整の方法

### 1. 重み付けマトリクス

各提案を以下の観点で評価（1-5 点）：

| 提案   | セキュリティ | 保守性 | パフォーマンス | 実装コスト | 総合 |
| ------ | ------------ | ------ | -------------- | ---------- | ---- |
| 提案 A | 5            | 3      | 2              | 4          | 14   |
| 提案 B | 3            | 5      | 4              | 2          | 14   |
| 統合案 | 4            | 4      | 3              | 3          | 14   |

### 2. リスク-効果分析

```
高リスク・高効果 → 慎重に計画して実施
低リスク・高効果 → すぐに実施
高リスク・低効果 → 実施しない
低リスク・低効果 → 余裕があれば実施
```

### 3. 段階的アプローチ

相反する提案がある場合の段階的実装：

```
Phase 1: まず安全性を確保（セキュリティ、型安全性）
  ↓
Phase 2: 次に保守性を向上（SRP、可読性）
  ↓
Phase 3: その後パフォーマンス最適化
  ↓
Phase 4: 最後に美観と規約統一
```

---

## 意思決定フレームワーク

### デシジョンツリー

```
提案が相反する
  ├─ セキュリティに関わる？
  │   └─ Yes → セキュリティ優先
  │   └─ No → 次へ
  │
  ├─ データ整合性に関わる？
  │   └─ Yes → 整合性優先
  │   └─ No → 次へ
  │
  ├─ 将来的なバグのリスクは？
  │   ├─ 高い → 保守性優先
  │   ├─ 低い → 次へ
  │
  ├─ 実装コストは？
  │   ├─ 高い → シンプルな方を選択
  │   ├─ 低い → より良い設計を選択
  │
  └─ チームの習熟度は？
      ├─ 低い → シンプルで理解しやすい方
      └─ 高い → より高度な設計
```

### チェックリスト

相反する提案を評価する際のチェックリスト：

- [ ] どちらの提案もセキュリティリスクはないか？
- [ ] 実装コストと効果のバランスは妥当か？
- [ ] チームのスキルレベルで実装・保守可能か？
- [ ] 既存システムとの互換性は保たれるか？
- [ ] テストは十分に書けるか？
- [ ] 将来的な拡張性は確保されるか？
- [ ] ドキュメント化は可能か？

---

## 実践例

### 例 1: 大きな関数の分割

**SRP の提案**: 150 行の関数を 5 つに分割
**KISS の提案**: 現状維持、コメントで明確化

**分析**:

- 関数の複雑度: 高（サイクロマティック複雑度 > 10）
- 変更頻度: 月に 2-3 回
- テストの難しさ: 高（多くのモックが必要）

**決定**: SRP を優先し、3 つの関数に分割

- 理由: テスト容易性と保守性の向上が変更コストを上回る
- ただし、過度な分割は避け、論理的なまとまりを維持

**実装計画**:

```typescript
// Phase 1: まず大きく3つに分割（データ取得、処理、保存）
function processOrder(orderId: string) {
  const orderData = fetchOrderData(orderId);
  const processedOrder = processOrderLogic(orderData);
  saveProcessedOrder(processedOrder);
}

// Phase 2（将来）: 必要に応じてさらに分割
```

---

### 例 2: 型定義の厳格さ

**TypeScript の提案**: すべての `any` を削除、厳格な型定義
**開発速度の要求**: 今週中にリリース必要

**分析**:

- 現在の `any` の数: 50 箇所
- 型エラーによる実際のバグ: 過去 3 ヶ月で 2 件
- リリース期限: 3 日後

**決定**: 段階的アプローチ

1. **即時**: 公開 API とセキュリティ関連のみ厳格化（10 箇所）
2. **来週**: 内部 API の型定義（20 箇所）
3. **来月**: 残りの型定義（20 箇所）

---

## まとめ

トレードオフ分析の原則：

1. **セキュリティと安定性を最優先**
2. **実装コストと効果のバランスを考慮**
3. **段階的アプローチで リスクを最小化**
4. **チームの現実を無視しない**
5. **完璧を求めず、継続的改善を目指す**

このガイドを活用して、現実的で効果的な改善計画を策定してください。
