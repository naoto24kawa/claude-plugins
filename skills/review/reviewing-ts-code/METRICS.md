# コード改善の成功指標ガイド

コードレビューと改善の効果を定量的に測定するための包括的な指標ガイドです。

---

## 目次

1. [コード品質メトリクス](#コード品質メトリクス)
2. [開発効率メトリクス](#開発効率メトリクス)
3. [運用品質メトリクス](#運用品質メトリクス)
4. [ビジネス価値メトリクス](#ビジネス価値メトリクス)
5. [測定方法とツール](#測定方法とツール)
6. [目標設定のガイドライン](#目標設定のガイドライン)

---

## コード品質メトリクス

### 1. サイクロマティック複雑度（Cyclomatic Complexity）

**定義**: コードの制御フローの複雑さを示す指標

**測定方法**:

```bash
# TypeScript/JavaScript
npx ts-complexity src/**/*.ts

# ESLint で測定
npx eslint --plugin complexity --rule 'complexity: ["error", 10]'
```

**目標値**:

- 関数単位: **10 以下が理想**、15 以下が許容範囲
- ファイル単位: **50 以下が理想**
- プロジェクト全体: 平均**8 以下**

**改善のヒント**:

- 条件分岐を減らす（早期リターン、ガード句）
- ポリモーフィズムで分岐を置き換え
- 複雑なロジックを小さな関数に分割

---

### 2. コード重複率（Code Duplication）

**定義**: 重複したコードの割合

**測定方法**:

```bash
# jscpd で測定
npx jscpd src/ --min-tokens 50 --format "json"

# SonarQube で測定
sonar-scanner -Dsonar.projectKey=myproject
```

**目標値**:

- **5%以下が理想**
- 10%以下が許容範囲
- 重複ブロック: **50 トークン以上を検出対象**

**改善のヒント**:

- 共通処理を関数/クラスに抽出
- ユーティリティモジュールの作成
- 高階関数やジェネリクスの活用

---

### 3. テストカバレッジ（Test Coverage）

**定義**: テストでカバーされているコードの割合

**測定方法**:

```bash
# Jest
npm test -- --coverage

# Istanbul
nyc npm test
```

**目標値**:

- **行カバレッジ**: 80%以上
- **分岐カバレッジ**: 75%以上
- **関数カバレッジ**: 85%以上
- **重要なビジネスロジック**: 95%以上

**改善のヒント**:

- Critical/High 優先度のコードから優先的にカバー
- エッジケースのテストを追加
- テスト容易性を考慮した設計

---

### 4. コード行数メトリクス

**定義**: コードの規模を測る指標

**測定方法**:

```bash
# cloc（Count Lines of Code）
cloc src/

# 関数あたりの行数
npx eslint --plugin max-lines-per-function
```

**目標値**:

- 関数: **50 行以下が理想**、100 行以下が許容範囲
- ファイル: **300 行以下が理想**、500 行以下が許容範囲
- クラス: **400 行以下が理想**

**改善のヒント**:

- 大きな関数を論理的な単位で分割
- ファイルを機能ごとに分割
- 適切な抽象化レベルを維持

---

### 5. 技術的負債比率（Technical Debt Ratio）

**定義**: コード修正にかかる推定時間と開発時間の比率

**測定方法**:

```bash
# SonarQube
# Technical Debt Ratio = 修正コスト / 開発コスト * 100
```

**目標値**:

- **5%以下が優秀**
- 10%以下が良好
- 20%以上は要改善

**改善のヒント**:

- 定期的なリファクタリング時間を確保
- 新規コードで負債を増やさない
- 段階的に既存負債を返済

---

## 開発効率メトリクス

### 1. 機能追加時間（Feature Lead Time）

**定義**: 機能の企画から本番リリースまでの時間

**測定方法**:

```
プロジェクト管理ツール（Jira、GitHub Projects）で追跡
- 着手から完了までの経過時間を記録
```

**目標値**:

- 小規模機能: **3 日以内**
- 中規模機能: **1 週間以内**
- 大規模機能: **2 週間以内**

**改善の指標**:

- ベースライン（改善前）から**20%短縮**を目指す
- コードレビュー時間の短縮が寄与

---

### 2. バグ修正時間（Bug Fix Time）

**定義**: バグ報告から修正完了までの時間

**測定方法**:

```
課題管理ツールで追跡
- Critical: 報告から修正完了まで
- High/Medium/Low: 同様に追跡
```

**目標値**:

- Critical: **4 時間以内**
- High: **1 日以内**
- Medium: **3 日以内**
- Low: **1 週間以内**

**改善の指標**:

- 平均修正時間を**30%短縮**
- コードの可読性向上が寄与

---

### 3. コードレビュー時間（Code Review Time）

**定義**: プルリクエストのレビューにかかる時間

**測定方法**:

```bash
# GitHub API で測定
gh pr list --state merged --json createdAt,mergedAt

# レビュー開始からマージまでの時間を計算
```

**目標値**:

- 初回レビュー着手: **4 時間以内**
- レビュー完了: **1 日以内**
- 平均ラウンド数: **2 回以下**

**改善の指標**:

- コード品質向上でレビュー指摘が減少
- レビュー時間が**25%短縮**

---

### 4. ビルド・テスト実行時間

**定義**: CI/CD パイプラインの実行時間

**測定方法**:

```bash
# GitHub Actions
gh run list --workflow=CI

# 平均実行時間を計算
```

**目標値**:

- ユニットテスト: **2 分以内**
- 統合テスト: **5 分以内**
- 全体の CI パイプライン: **10 分以内**

**改善の指標**:

- テストの並列化で**30%高速化**
- 不要なテストを削除

---

## 運用品質メトリクス

### 1. インシデント発生率

**定義**: 本番環境で発生する障害の頻度

**測定方法**:

```
監視ツール（Datadog、New Relic）で追跡
- エラーレート
- 5xx レスポンスの割合
```

**目標値**:

- **月間インシデント数: 5 件以下**
- Critical インシデント: **月 1 件以下**
- エラーレート: **0.1%以下**

**改善の指標**:

- コード品質向上でインシデントが**50%減少**
- 型安全性向上が寄与

---

### 2. 平均復旧時間（MTTR - Mean Time To Recovery）

**定義**: 障害発生から復旧までの平均時間

**測定方法**:

```
インシデント管理ツールで追跡
- 障害検知から復旧完了までの時間
```

**目標値**:

- Critical: **30 分以内**
- High: **2 時間以内**
- Medium: **4 時間以内**

**改善の指標**:

- コードの可読性向上で原因特定が迅速化
- MTTR が**40%短縮**

---

### 3. デプロイ頻度

**定義**: 本番環境へのデプロイ回数

**測定方法**:

```bash
# Git タグから測定
git log --tags --simplify-by-decoration --pretty="format:%ai %d"
```

**目標値**:

- **週 1 回以上**（理想は日次）
- デプロイ成功率: **95%以上**

**改善の指標**:

- CI/CD 改善とコード品質向上で**デプロイ頻度 2 倍**
- ロールバック率が減少

---

### 4. 変更失敗率（Change Failure Rate）

**定義**: デプロイ後に障害が発生する割合

**測定方法**:

```
失敗デプロイ数 / 全デプロイ数 * 100
```

**目標値**:

- **5%以下**（エリートレベル）
- 10%以下が良好
- 15%以上は要改善

**改善の指標**:

- テストカバレッジ向上で**変更失敗率を半減**

---

## ビジネス価値メトリクス

### 1. リリース頻度

**定義**: 新機能のリリース頻度

**測定方法**:

```
プロダクトマネジメントツールで追跡
- 月間リリース回数
```

**目標値**:

- **月 2 回以上**のメジャーリリース
- 週 1 回以上のマイナーリリース

**改善の指標**:

- 開発効率向上で**リリース頻度 1.5 倍**

---

### 2. 顧客満足度（CSAT）

**定義**: ユーザーの満足度スコア

**測定方法**:

```
ユーザーアンケート、NPS（Net Promoter Score）
```

**目標値**:

- CSAT: **80%以上**
- NPS: **30 以上**

**改善の指標**:

- バグ減少と機能追加速度向上で**CSAT 10 ポイント向上**

---

### 3. 開発者生産性（Developer Velocity）

**定義**: 開発者の作業効率

**測定方法**:

```
# Story Points / Sprint
# または コミット数、PR数など
```

**目標値**:

- ベロシティの**15%向上**
- 開発者満足度スコア: **4/5 以上**

---

## 測定方法とツール

### 推奨ツール

#### コード品質

- **SonarQube / SonarCloud**: 総合的なコード品質分析
- **ESLint**: JavaScript コード品質チェック
- **ts-complexity**: TypeScript 複雑度分析
- **jscpd**: コード重複検出

#### テスト

- **Jest**: テストフレームワーク＆カバレッジ
- **Istanbul/nyc**: カバレッジレポート

#### CI/CD

- **GitHub Actions**: CI/CD パイプライン
- **CircleCI / GitLab CI**: 代替 CI/CD

#### 監視・運用

- **Datadog**: APM、ログ、メトリクス
- **New Relic**: パフォーマンス監視
- **Sentry**: エラートラッキング

---

## 目標設定のガイドライン

### SMART 原則に基づく目標設定

**Specific（具体的）**: "コード品質を向上させる" ではなく "サイクロマティック複雑度を 15 から 10 以下に削減"

**Measurable（測定可能）**: 定量的な指標で測定できる

**Achievable（達成可能）**: 現実的な目標値を設定

**Relevant（関連性）**: ビジネス目標と連動

**Time-bound（期限付き）**: "3 ヶ月以内に"などの期限を設定

### 目標設定の例

#### 短期目標（1-3 ヶ月）

- [ ] テストカバレッジを 60%から 75%に向上
- [ ] Critical バグの平均修正時間を 8 時間から 4 時間に短縮
- [ ] コードレビュー時間を平均 2 日から 1 日に短縮

#### 中期目標（3-6 ヶ月）

- [ ] サイクロマティック複雑度を平均 12 から 8 に削減
- [ ] コード重複率を 15%から 5%に削減
- [ ] デプロイ頻度を月 1 回から週 1 回に増加

#### 長期目標（6-12 ヶ月）

- [ ] 技術的負債比率を 20%から 5%に削減
- [ ] インシデント発生率を月 10 件から 5 件に削減
- [ ] 開発ベロシティを 30%向上

---

## ダッシュボード構成例

### 推奨ダッシュボード構成

```
┌─────────────────────────────────────────┐
│  コード品質ダッシュボード                 │
├─────────────────────────────────────────┤
│  複雑度: ██████░░░░ 8.2 (目標: 8以下)   │
│  重複率: ████░░░░░░ 4.5% (目標: 5%以下) │
│  カバレッジ: ████████░░ 78% (目標: 80%) │
│  技術的負債: ██████░░░░ 6% (目標: 5%)   │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  開発効率ダッシュボード                   │
├─────────────────────────────────────────┤
│  機能追加時間: 5.2日 (目標: 5日以下)     │
│  レビュー時間: 18時間 (目標: 24時間以下) │
│  デプロイ頻度: 週1.2回 (目標: 週1回以上)│
└─────────────────────────────────────────┘
```

---

## まとめ

成功指標の活用ポイント：

1. **ベースラインを測定**: まず現状を把握
2. **優先度を決定**: すべての指標を一度に改善しようとしない
3. **定期的にレビュー**: 月次でメトリクスを確認
4. **チームで共有**: 透明性を保ち、全員で改善に取り組む
5. **継続的に改善**: 小さな改善を積み重ねる

これらの指標を活用して、コード品質向上の効果を可視化し、継続的な改善サイクルを回しましょう。
